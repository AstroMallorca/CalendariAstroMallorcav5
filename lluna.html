<!doctype html>
<html lang="ca">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Lluna</title>
  <link rel="icon" href="assets/icons/astromallorca.png">

  <style>
:root{
  /* DIA (per defecte) */
  --bg:#ffffff;
  --text:#111111;
  --muted:rgba(0,0,0,.65);
  --border:rgba(0,0,0,.18);
  --card: rgba(0,0,0,0.03);

  /* colors FIXES (no canvien en mode nocturn) */
  --perigeuFixed:#ffd400;
  --apogeuFixed:#19d6ff;
  --perigeu: var(--perigeuFixed);
  --apogeu:  var(--apogeuFixed);

}

/* NOCTURN (heretat de l'app: body.nocturn) */
body.nocturn{
  --bg:#000000;
  --text:#ff2a2a;
  --muted:rgba(255,42,42,.75);
  --border:rgba(255,42,42,.35);
  --card: rgba(255,42,42,0.06);

  /* mantenim els colors FIXES */
}

body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, sans-serif;
  background:var(--bg);
  color:var(--text);
  padding:16px;
}

a{ color: var(--text); text-decoration:none; opacity:.9; }
a:active{ opacity:1; }

.wrap{ max-width:520px; margin:0 auto; }

.topbar{
  display:flex;
  align-items:center;
  justify-content:flex-start;
  gap:12px;
}
/* Barra de t√≠tol amb fletxes (canvi de dia) */
.daybar{
  display:grid;
  grid-template-columns: 56px 1fr 56px;
  align-items:center;
  gap: 6px;
  margin: 6px 0 6px;
}

.daybar h1{
  margin: 0;              /* IMPORTANT: anul¬∑la el margin que tens a h1 */
  font-size: 34px;
  font-weight: 800;
  letter-spacing: .2px;
  text-align:center;
}

/* Fletxes ‚Äúnetes‚Äù (sense cercle) */
.navArrow{
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 44px;
  line-height: 1;
  font-weight: 800;
  opacity: .9;
  user-select:none;
  -webkit-tap-highlight-color: transparent;
}

.navArrow:active{ opacity:1; }
.navArrow.disabled{
  opacity:.25;
  pointer-events:none;
}

.err{
  margin-top:16px;
  padding:10px 12px;
  border:1px solid var(--border);
  border-radius:12px;
  font-size:14px;
  background: var(--card);
  display:none;
}

/* Cap√ßalera */
.center{ text-align:center; }

h1{
  margin: 8px 0 6px;
  font-size: 34px;
  font-weight: 800;
  letter-spacing: .2px;
}

.phaseTitle{
  margin: 0;
  font-size: 40px;
  line-height: 1.05;
  letter-spacing: -0.5px;
}

.meta{
  color:var(--muted);
  margin: 8px 0 0;
  font-size: 18px;
}

/* LLUNA */
.moonbox{
  display:flex;
  justify-content:center;
  margin: 12px 0 6px;
}
.moonbox svg{
  width: 170px;
  height: 170px;
  max-width: 60vw;
  max-height: 60vw;
  overflow: visible;
}

/* Llegenda */
.legend{
  text-align:center;
  color:var(--muted);
  font-size: 15px;
  margin: 6px 0 10px;
  line-height: 1.2;
}

.legend .peri{ color: var(--perigeuFixed); font-weight: 800; }
.legend .apo{  color: var(--apogeuFixed);  font-weight: 800; }

/* Cards com a la resta de p√†gines */
.card{
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 14px;
  margin: 12px 0;
}

/* KPI en 2 columnes (label / valor) */
.kpi{
  display:grid;
  grid-template-columns: 1fr auto;
  row-gap: 10px;
  column-gap: 12px;
  font-size: 20px;
}
.kpi .k{ color: var(--muted); }
.kpi .v{
  text-align:right;
  font-weight: 800;
  font-variant-numeric: tabular-nums;
  white-space: nowrap;
}

#back{ color: var(--text); opacity: .9; }

@media (max-width: 360px){
  .phaseTitle{ font-size: 34px; }
  .kpi{ font-size: 18px; }
}
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <a href="#" id="back">‚Üê Tornar</a>
    </div>

<div class="center">
  <div class="daybar">
    <a href="#" class="navArrow" id="prevDay" aria-label="Dia anterior">‚Äπ</a>
    <h1>La Lluna avui</h1>
    <a href="#" class="navArrow" id="nextDay" aria-label="Dia seg√ºent">‚Ä∫</a>
  </div>

  <div class="phaseTitle" id="title">‚Äî</div>
  <div class="meta">
  <span id="d"></span><br>
  <span id="age">Edat de la Lluna: ‚Äî</span>
</div>

</div>


    <div class="moonbox" id="moonbox"></div>

    <div class="legend" id="legend">
      <span class="peri">perigeu</span> / <span class="apo">apogeu</span>
    </div>

<div class="card">
  <div style="font-weight:800; font-size:18px; margin-bottom:10px; text-align:center;">
    Dades de la Lluna
  </div>

  <div class="kpi" id="kpi">
    <div class="k">Sortida:</div><div class="v" id="kRise">‚Äî</div>
    <div class="k">Posta:</div><div class="v" id="kSet">‚Äî</div>
    <div class="k">Durada:</div><div class="v" id="kAbove">‚Äî</div>
    <div class="k">Altura max:</div><div class="v" id="chartTitle">‚Äî</div>
    <div class="k">Il¬∑luminaci√≥:</div><div class="v" id="kIll">‚Äî</div>
    <div class="k">Fase:</div><div class="v" id="kPhaseDeg">‚Äî</div>
    <div class="k">Mida aparent:</div><div class="v" id="kSize">‚Äî</div>
    <div class="k">Dist√†ncia:</div><div class="v" id="kDist">‚Äî</div>
  </div>
</div>

<div class="card" id="astroCard" style="display:none;">
  <div style="font-weight:800; font-size:18px; margin-bottom:8px;">üåë Bon dia per astrofotografia</div>
<div style="color:var(--muted); margin-bottom:10px;">
  &nbsp;
</div>

  <div class="kpi">
    <div class="k">Inici (vespre):</div><div class="v" id="astroStart">‚Äî</div>
    <div class="k">Final (matinada):</div><div class="v" id="astroEnd">‚Äî</div>
    <div class="k">Temps sense lluna:</div><div class="v" id="astroDur">‚Äî</div>
  </div>

  <div style="margin-top:10px; color:var(--muted); font-size:14px; line-height:1.25;">
    Es calcula des del final del dia seleccionat (posta de sol o posta de la Lluna, el que passi m√©s tard)
    fins a la matinada seg√ºent (sortida de sol o sortida de la Lluna, el que passi abans).
  </div>
</div>

    <div class="err" id="err"></div>
  </div>

  <!-- astronomy-engine (local) -->
  <script src="assets/js/astronomy.browser.min.js"></script>

  <script>
    const p = new URLSearchParams(location.search);
    const dateStr = p.get("date"); // "YYYY-MM-DD"
    function isoToDMY(iso){
  if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return "";
  const [y,m,d] = iso.split("-");
  return `${d}-${m}-${y}`;   // si ho vols amb barres: `${d}/${m}/${y}`
}

document.getElementById("d").textContent = isoToDMY(dateStr);

function isoFromLocalDate(d){
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,"0");
  const da = String(d.getDate()).padStart(2,"0");
  return `${y}-${m}-${da}`;
}

function parseISODateAtMidnightLocal(iso){
  if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return null;
  const [y,m,d] = iso.split("-").map(Number);
  return new Date(y, m-1, d, 0, 0, 0, 0);
}

function buildUrlForDate(newISO){
  const q = new URLSearchParams(location.search);
  q.set("date", newISO);
  if (!q.get("back")) q.set("back", "efemerides.html"); // o index.html
  return `${location.pathname}?${q.toString()}`;
}

// Base del dia: si no hi ha dateStr, agafa avui
const baseDay = parseISODateAtMidnightLocal(dateStr) || (() => {
  const now = new Date();
  return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0,0);
})();

// Enlla√ßos prev/next
const prev = new Date(baseDay); prev.setDate(prev.getDate() - 1);
const next = new Date(baseDay); next.setDate(next.getDate() + 1);

const prevISO = isoFromLocalDate(prev);
const nextISO = isoFromLocalDate(next);

const prevA = document.getElementById("prevDay");
const nextA = document.getElementById("nextDay");

prevA.href = buildUrlForDate(prevISO);
nextA.href = buildUrlForDate(nextISO);

// Click = navegar (recarrega la p√†gina amb el nou dia)
prevA.addEventListener("click", (e) => { e.preventDefault(); location.href = prevA.href; });
nextA.addEventListener("click", (e) => { e.preventDefault(); location.href = nextA.href; });

// Si no hi havia dateStr, actualitza el text "Data:" amb el dia real
if (!dateStr){
  const todayISO = isoFromLocalDate(baseDay);
  document.getElementById("d").textContent = isoToDMY(todayISO);
}

   function buildUrlForDateOnPage(page, newISO){
  const q = new URLSearchParams(location.search);
  q.set("date", newISO);
  return `${page}?${q.toString()}`;
}

// on ha de tornar (tria un d‚Äôaquests)
const BACK_PAGE = "index.html";   // <-- si la teva p√†gina d‚Äôefem√®rides t√© aquest nom
// const BACK_PAGE = "index.html";     // <-- si vols tornar a la principal

function currentISOFromQueryOrToday(){
  const q = new URLSearchParams(location.search);
  const iso = q.get("date");
  if (iso && /^\d{4}-\d{2}-\d{2}$/.test(iso)) return iso;

  const now = new Date();
  const y = now.getFullYear();
  const m = String(now.getMonth()+1).padStart(2,"0");
  const d = String(now.getDate()).padStart(2,"0");
  return `${y}-${m}-${d}`;
}

const backA = document.getElementById("back");
backA.href = buildUrlForDateOnPage(BACK_PAGE, currentISOFromQueryOrToday());

backA.addEventListener("click", (e) => {
  e.preventDefault();
  location.href = backA.href;   // NO history.back()
});


    // ======= Localitzaci√≥ =======
    function numParam(name, fallback){
      const v = p.get(name);
      const x = (v === null) ? NaN : Number(v);
      return Number.isFinite(x) ? x : fallback;
    }

    // Palma per defecte si no ve res
    const LAT  = numParam("lat", 39.5696);
    const LON  = numParam("lon", 2.6502);
    const ELEV = numParam("elev", 0);

    function getObserver(){
      return new Astronomy.Observer(LAT, LON, ELEV);
    }

    function parseISODateLocal(iso){
      if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return new Date();
      const [y,m,d] = iso.split("-").map(Number);
      return new Date(y, m-1, d, 12, 0, 0); // migdia local
    }

    function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
    function deg2rad(d){ return d * Math.PI / 180; }
    // Altituds ‚Äúest√†ndard‚Äù per rise/set (aprox.)
    // Sol: -0.833¬∞ (refacci√≥ + radi solar)
    // Lluna: -0.3¬∞ (refacci√≥ + radi lunar aprox.)
    const SUN_EVENT_ALT  = -0.833;
    const MOON_EVENT_ALT = -0.3;

    function fmtPct(x, decimals = 2){
      if (!Number.isFinite(x)) return "‚Äî";
      return `${x.toFixed(decimals)}%`;
    }

    function fmtTimeHM(d){
      return new Intl.DateTimeFormat("ca-ES", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false
      }).format(d);
    }

    function fmtDurationHM(ms){
      if (!Number.isFinite(ms) || ms < 0) return "‚Äî";
      const totalMin = Math.round(ms / 60000);
      const h = Math.floor(totalMin / 60);
      const m = totalMin % 60;
      return `${h}h ${m}‚Ä≤`;
    }

    function inSameLocalDay(d, day){
      const a0 = new Date(day); a0.setHours(0,0,0,0);
      const a1 = new Date(day); a1.setHours(23,59,59,999);
      return d >= a0 && d <= a1;
    }

    // ======= FASE EXACTA =======
    function phaseExactEventForDay(day){
      const t0 = Astronomy.MakeTime(day);
      const targets = [
        { angle: 0,   name: "Lluna nova" },
        { angle: 90,  name: "Quart creixent" },
        { angle: 180, name: "Lluna plena" },
        { angle: 270, name: "Quart minvant" },
      ];

      for (const it of targets){
        const fwd  = Astronomy.SearchMoonPhase(it.angle, t0,  3);
        const back = Astronomy.SearchMoonPhase(it.angle, t0, -3);

        if (fwd  && inSameLocalDay(fwd.date,  day)) return { name: it.name, date: fwd.date  };
        if (back && inSameLocalDay(back.date, day)) return { name: it.name, date: back.date };
      }
      return null;
    }

    function phaseLabelForDay(phaseDeg, illum, day){
      const exactEv = phaseExactEventForDay(day);
      if (exactEv) return exactEv.name;

      const d = ((phaseDeg % 360) + 360) % 360;
      if (d > 0 && d < 180){
        return (illum < 0.5) ? "Crescent creixent" : "Gibosa creixent";
      } else {
        return (illum < 0.5) ? "Crescent minvant" : "Gibosa minvant";
      }
    }

    function moonAgeDays(day){
      const t = Astronomy.MakeTime(day);
      const prevNew = Astronomy.SearchMoonPhase(0, t, -35);
      if (!prevNew) return null;
      const ms = day.getTime() - prevNew.date.getTime();
      return ms / (1000 * 60 * 60 * 24);
    }

    function titleCaseCatalan(s){
      s = (s || "").trim();
      if (!s) return s;
      return s.charAt(0).toUpperCase() + s.slice(1);
    }

    // ======= DIST√ÄNCIA / APSIS / SUPERLLUNA =======
    function toDate(x){
      if (!x) return null;

      // ja √©s Date
      if (x instanceof Date) return Number.isFinite(x.getTime()) ? x : null;

      // si √©s un objecte retornat per Astronomy (rise/set/transit)
      if (x.date instanceof Date) return Number.isFinite(x.date.getTime()) ? x.date : null;

      // si √©s un AstroTime amb m√®tode .ToDate()
      if (typeof x.ToDate === "function"){
        const d = x.ToDate();
        return (d instanceof Date && Number.isFinite(d.getTime())) ? d : null;
      }

      return null;
    }

    function safeMakeTime(x){
      // evita petades si ens arriba un event en lloc d‚Äôun Date
      const d = toDate(x) || x;   // si ja √©s AstroTime, el deixam passar
      return Astronomy.MakeTime(d);
    }

    function moonDistanceKmAt(date){
      const t = safeMakeTime(date);
      const v = Astronomy.GeoVector(Astronomy.Body.Moon, t, true);
      const rAU = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
      const AU_KM = (typeof Astronomy.AU_KM === "number") ? Astronomy.AU_KM : 149597870.7;
      return rAU * AU_KM;
    }

    function apsisTagForDay(day, spanDays = 2, stepHours = 1){
      const start = new Date(day); start.setHours(0,0,0,0);
      const end   = new Date(day); end.setHours(23,59,59,999);

      const center = new Date(day); center.setHours(12,0,0,0);
      const t0 = new Date(center.getTime() - spanDays*24*3600*1000);
      const t1 = new Date(center.getTime() + spanDays*24*3600*1000);

      let minD = Infinity, minT = null;
      let maxD = -Infinity, maxT = null;

      for (let tt = new Date(t0); tt <= t1; tt = new Date(tt.getTime() + stepHours*3600*1000)){
        const dkm = moonDistanceKmAt(tt);
        if (dkm < minD){ minD = dkm; minT = new Date(tt); }
        if (dkm > maxD){ maxD = dkm; maxT = new Date(tt); }
      }

      if (minT && minT >= start && minT <= end) return { tag: "perigeu", time: minT, distKm: minD };
      if (maxT && maxT >= start && maxT <= end) return { tag: "apogeu",  time: maxT, distKm: maxD };
      return null;
    }

    function isSupermoon(fullMoonDate){
      const fullKm = moonDistanceKmAt(fullMoonDate);

      const center = new Date(fullMoonDate);
      const t0 = new Date(center.getTime() - 7*24*3600*1000);
      const t1 = new Date(center.getTime() + 7*24*3600*1000);

      let minD = Infinity, minT = null;
      for (let tt = new Date(t0); tt <= t1; tt = new Date(tt.getTime() + 2*3600*1000)){
        const dkm = moonDistanceKmAt(tt);
        if (dkm < minD){ minD = dkm; minT = new Date(tt); }
      }
      if (!minT) return false;

      const dtHours = Math.abs(fullMoonDate.getTime() - minT.getTime()) / (1000*3600);
      return (dtHours <= 24) && (fullKm <= 360000);
    }

    // ======= ALTURA (per mostreig) =======
    function bodyAltitudeDeg(body, observer, date){
      const t = safeMakeTime(date);
      const eq = Astronomy.Equator(body, t, observer, true, true);
      if (!eq || !Number.isFinite(eq.ra) || !Number.isFinite(eq.dec)) return null;

      // Prova diferents formes de "refraction" segons la versi√≥
      let hor = null;

      try { hor = Astronomy.Horizon(t, observer, eq.ra, eq.dec, "none"); } catch(e) {}
      if (!hor) { try { hor = Astronomy.Horizon(t, observer, eq.ra, eq.dec, 0); } catch(e) {} }
      if (!hor) { try { hor = Astronomy.Horizon(t, observer, eq.ra, eq.dec, false); } catch(e) {} }
      if (!hor) { try { hor = Astronomy.Horizon(t, observer, eq.ra, eq.dec); } catch(e) {} }

      if (!hor || !Number.isFinite(hor.altitude)) return null;
      return hor.altitude;
    }

    // Troba el moment exacte (aprox) en qu√® l'altura creua targetAlt dins [tA, tB]
    function refineCrossingTime(body, observer, tA, tB, targetAlt = 0, iters = 25){
      let a = new Date(tA), b = new Date(tB);

      let fa = bodyAltitudeDeg(body, observer, a) - targetAlt;
      let fb = bodyAltitudeDeg(body, observer, b) - targetAlt;

      if (!Number.isFinite(fa) || !Number.isFinite(fb)) return null;
      if (fa === 0) return a;
      if (fb === 0) return b;

      if (fa * fb > 0) return null;

      for (let i = 0; i < iters; i++){
        const mid = new Date((a.getTime() + b.getTime()) / 2);
        const fm = bodyAltitudeDeg(body, observer, mid) - targetAlt;
        if (!Number.isFinite(fm)) return null;

        if (fa * fm <= 0){
          b = mid; fb = fm;
        }else{
          a = mid; fa = fm;
        }
      }
      return new Date((a.getTime() + b.getTime()) / 2);
    }

    // Escaneja altures i detecta rise/set
    function findRiseSetScan(body, observer, startDate, hours = 36, stepMinutes = 5, targetAlt = 0){
      const start = new Date(startDate);
      const end = new Date(start.getTime() + hours*3600*1000);
      const stepMs = stepMinutes*60*1000;

      let prevT = new Date(start);
      let prevAlt = bodyAltitudeDeg(body, observer, prevT);
      if (!Number.isFinite(prevAlt)) return { rise: null, set: null };

      let rise = null;
      let set  = null;

      for (let ms = start.getTime() + stepMs; ms <= end.getTime(); ms += stepMs){
        const t = new Date(ms);
        const alt = bodyAltitudeDeg(body, observer, t);
        if (!Number.isFinite(alt)) continue;

        const prevVal = prevAlt - targetAlt;
        const curVal  = alt     - targetAlt;

        if (!rise && prevVal < 0 && curVal >= 0){
          rise = refineCrossingTime(body, observer, prevT, t, targetAlt);
        }

        if (!set && prevVal >= 0 && curVal < 0){
          set = refineCrossingTime(body, observer, prevT, t, targetAlt);
        }

        if (rise && set) break;

        prevT = t;
        prevAlt = alt;
      }

      return { rise, set };
    }

    // Transit aproximat (m√†xim) per mostreig
    function findTransitByScan(body, observer, start, end, stepMinutes = 5){
      const stepMs = stepMinutes*60*1000;
      let bestAlt = -1e9;
      let bestTime = null;

      for (let t = start.getTime(); t <= end.getTime(); t += stepMs){
        const d = new Date(t);
        const alt = bodyAltitudeDeg(body, observer, d);
        if (Number.isFinite(alt) && alt > bestAlt){
          bestAlt = alt;
          bestTime = d;
        }
      }
      if (!bestTime) return null;
      return { time: bestTime, altDeg: bestAlt };
    }

    // Rise/Set ‚Äúcom a l‚Äôapp‚Äù
    function getRiseSetSameAsApp(body, observer, isoDateStr){
      const base = parseISODateLocal(isoDateStr);
      const start = new Date(base); start.setHours(0,0,0,0);
      const scan = findRiseSetScan(body, observer, start, 36, 5, 0);
      return { rise: scan.rise, set: scan.set };
    }
// ======= SVG LLUNA (fase + mida) =======
function renderMoonSVG(opts){
  const {
    R_perigeu = 108,
    R_apogeu  = 96,
    R_now     = 102,
    illum = 0.5,
    waxing = true
  } = opts;

  const cx = 120, cy = 120;
  const R = R_now;

  const cosPhi = (2 * clamp(illum, 0, 1)) - 1;
  let rx = Math.abs(cosPhi) * R;
  if (rx < 0.001) rx = 0.001;

  const isGibbous = illum > 0.5;
  const sweepLimb = waxing ? 1 : 0;

  let sweepTerm;
  if (!isGibbous) sweepTerm = waxing ? 0 : 1;
  else            sweepTerm = waxing ? 1 : 0;

  const almostNew  = illum < 0.01;
  const almostFull = illum > 0.99;

  const pathLit = `
    M ${cx} ${cy - R}
    A ${R} ${R} 0 0 ${sweepLimb} ${cx} ${cy + R}
    A ${rx} ${R} 0 0 ${sweepTerm} ${cx} ${cy - R}
    Z
  `;

  const IMG = "assets/moon/plena.png";

  return `
<svg viewBox="0 0 240 240" aria-label="Fase lunar" role="img">
  <defs>
    <clipPath id="clipDisc"><circle cx="${cx}" cy="${cy}" r="${R}"></circle></clipPath>

    <mask id="maskShadow">
      <rect x="0" y="0" width="240" height="240" fill="black"></rect>
      <circle cx="${cx}" cy="${cy}" r="${R}" fill="white"></circle>
      ${almostNew ? "" : `<path d="${pathLit}" fill="black"></path>`}
    </mask>

    <mask id="maskLit">
      <rect x="0" y="0" width="240" height="240" fill="black"></rect>
      ${
        almostFull
          ? `<circle cx="${cx}" cy="${cy}" r="${R}" fill="white"></circle>`
          : (almostNew ? "" : `<path d="${pathLit}" fill="white"></path>`)
      }
    </mask>
  </defs>

  <circle cx="${cx}" cy="${cy}" r="${R_perigeu}" fill="none" stroke="var(--perigeuFixed)" stroke-width="2.5"></circle>
  <circle cx="${cx}" cy="${cy}" r="${R_apogeu}"  fill="none" stroke="var(--apogeuFixed)"  stroke-width="2.5"></circle>

  <g clip-path="url(#clipDisc)">
    <image href="${IMG}" x="${cx-R}" y="${cy-R}" width="${2*R}" height="${2*R}"
           preserveAspectRatio="xMidYMid slice" opacity="0.75"></image>
  </g>

  <g clip-path="url(#clipDisc)" mask="url(#maskLit)">
    <image href="${IMG}" x="${cx-R}" y="${cy-R}" width="${2*R}" height="${2*R}"
           preserveAspectRatio="xMidYMid slice" opacity="1"></image>
  </g>

  <g clip-path="url(#clipDisc)" mask="url(#maskShadow)">
    <rect x="${cx-R}" y="${cy-R}" width="${2*R}" height="${2*R}" fill="rgba(0,0,0,0.65)"></rect>
  </g>

  <circle cx="${cx}" cy="${cy}" r="${R}" fill="none" stroke="rgba(0,0,0,0.25)" stroke-width="1"></circle>
</svg>`;
}
// === Helper robust: convertir qualsevol ‚Äúevent/time‚Äù a Date ===
function evToDateAny(x){
  if (!x) return null;

  // format { date: ... } -> recursiu
  if (x.date) return evToDateAny(x.date);

  // ja √©s Date
  if (x instanceof Date) return Number.isFinite(x.getTime()) ? x : null;

  // AstroTime amb ToDate()
  if (typeof x.ToDate === "function"){
    const d = x.ToDate();
    return (d instanceof Date && Number.isFinite(d.getTime())) ? d : null;
  }

  // AstroTime alternatiu amb .ut (JD UTC)
  if (typeof x.ut === "number" && Number.isFinite(x.ut)){
    const ms = (x.ut - 2440587.5) * 86400000;
    const d = new Date(ms);
    return Number.isFinite(d.getTime()) ? d : null;
  }

  return null;
}

// === Rise/Set EXACTE com a la p√†gina d‚Äôefem√®rides (SearchRiseSet) ===
// IMPORTANT: altitude = MOON_EVENT_ALT si vols refinar; si vols clavar la vella exacta, usa 0.
function getRiseSetSameAsEfemerides(body, observer, iso){
  if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return { rise:null, set:null };

  const [Y,M,D] = iso.split("-").map(Number);
  const start = new Date(Y, M-1, D, 0, 0, 0);   // 00:00 local
  const t0 = Astronomy.MakeTime(start);

  const alt = 0;  // <-- PROVA AIX√í PRIMER
  // si vols la versi√≥ vella ‚Äútal qual‚Äù, posa: const alt = 0;

  const riseEv = Astronomy.SearchRiseSet(body, observer, +1, t0, 1, alt);
  const setEv  = Astronomy.SearchRiseSet(body, observer, -1, t0, 1, alt);

  return {
    rise: evToDateAny(riseEv),
    set:  evToDateAny(setEv),
  };
}

    (async () => {
      const errEl = document.getElementById("err");
      try{
        const day = parseISODateLocal(dateStr || "");
        const observer = getObserver();

        // IL¬∑LUMINACI√ì / PHASE
        const t = Astronomy.MakeTime(day);
        const illum = Astronomy.Illumination(Astronomy.Body.Moon, t).phase_fraction;
        const phaseDeg = Astronomy.MoonPhase(t);

        // waxing? (aprox)
        const waxing = ((phaseDeg % 360) + 360) % 360 < 180;

        // dist√†ncia i mida aparent
        const v = Astronomy.GeoVector(Astronomy.Body.Moon, t, true);
        const rAU = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
        const AU_KM = (typeof Astronomy.AU_KM === "number") ? Astronomy.AU_KM : 149597870.7;
        const distKm = rAU * AU_KM;

        const R_MOON_KM = 1737.4;
        const angRad = 2 * Math.atan(R_MOON_KM / distKm);
        const angArcmin = (angRad * 180 / Math.PI) * 60;
        const angDeg = angArcmin / 60;

        const APog = 29.4;
        const PErig = 33.5;
        const R_perigeu = 108;
        const R_apogeu  = 96;

        const u = clamp((angArcmin - APog) / (PErig - APog), 0, 1);
        const R_now = R_apogeu + u * (R_perigeu - R_apogeu);

        // T√çTOL + Superlluna
        const exactEv = phaseExactEventForDay(day);
        const label = phaseLabelForDay(phaseDeg, illum, day);

        let title = titleCaseCatalan(label);
        if (exactEv && exactEv.name === "Lluna plena" && isSupermoon(exactEv.date)){
          title += " ¬∑ Superlluna";
        }
        document.getElementById("title").textContent = title;

        // KPI
        document.getElementById("kIll").textContent      = fmtPct(illum*100, 2);
        document.getElementById("kPhaseDeg").textContent = `${phaseDeg.toFixed(1)}¬∞`;
        document.getElementById("kSize").textContent = `${angDeg.toFixed(2)}¬∫`;

        const apsis = apsisTagForDay(day);
        const apsisTxt = apsis ? ` (${apsis.tag})` : "";
        document.getElementById("kDist").textContent =
          `${Math.round(distKm).toLocaleString("ca-ES")} km${apsisTxt}`;

        // Edat
        const age = moonAgeDays(day);
        document.getElementById("age").textContent = Number.isFinite(age)
          ? `Edat de la Lluna: ${age.toFixed(1)} dies`
          : "Edat de la Lluna: ‚Äî";

        // SVG Lluna
        const box = document.getElementById("moonbox");
        // Si la teva renderMoonSVG original √©s al mateix fitxer, crida-la directament:
        box.innerHTML = renderMoonSVG({ R_perigeu, R_apogeu, R_now, illum, waxing });

        // ======= Rise / Set / Altura max (sense gr√†fic) =======
        const day0 = new Date(day);
        day0.setHours(0,0,0,0);

        if (!Number.isFinite(day0.getTime())){
          throw new Error("Dia inv√†lid (dateStr). Revisa ?date=YYYY-MM-DD");
        }

        const rs = getRiseSetSameAsEfemerides(Astronomy.Body.Moon, observer, dateStr);
const rise = rs.rise;
const set  = rs.set;
        // ======= ‚≠ê Astrofoto (3 dies abans de Lluna nova) =======
        const astroCard = document.getElementById("astroCard");

        function nextDayISO(iso){
          const [y,m,d] = iso.split("-").map(Number);
          const dt = new Date(y, m-1, d, 12, 0, 0);
          dt.setDate(dt.getDate() + 1);
          return `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,"0")}-${String(dt.getDate()).padStart(2,"0")}`;
        }

function isWithin3DaysNearNewMoon(dayLocalNoon){
  const t0 = Astronomy.MakeTime(dayLocalNoon);

  // propera Lluna nova (cap endavant) i l'anterior (cap enrere)
  const nmNextTime = Astronomy.SearchMoonPhase(0, t0, +10);
  const nmPrevTime = Astronomy.SearchMoonPhase(0, t0, -10);


  const nmNext = evToDateAny(nmNextTime) || (nmNextTime && nmNextTime.date ? new Date(nmNextTime.date) : null);
  const nmPrev = evToDateAny(nmPrevTime) || (nmPrevTime && nmPrevTime.date ? new Date(nmPrevTime.date) : null);

  if (!nmNext && !nmPrev) return { ok:false, nmDate:null, diffDays:null, side:null };

  const day0 = new Date(dayLocalNoon); day0.setHours(0,0,0,0);

  function diffDaysTo(d){
    const x = new Date(d); x.setHours(0,0,0,0);
    return Math.floor(((x.getTime() - day0.getTime()) / 86400000) + 0.5);
  }

  let best = null;

  if (nmNext){
    const dn = diffDaysTo(nmNext); // pot ser 0..+‚àû
    best = { nmDate: nmNext, diffDays: dn, side: (dn >= 0 ? "abans" : "despres") };
  }

  if (nmPrev){
    const dp = diffDaysTo(nmPrev); // normalment <= 0
    const cand = { nmDate: nmPrev, diffDays: dp, side: (dp <= 0 ? "despres" : "abans") };

    if (!best || Math.abs(dp) < Math.abs(best.diffDays)) best = cand;
  }

  const ok = Math.abs(best.diffDays) <= 3;   // ‚úÖ -3..+3
  return { ok, ...best };
}

        const check = isWithin3DaysNearNewMoon(day);
        console.log("[ASTRO]", dateStr, check);

        if (astroCard && check.ok){
          const isoToday = (dateStr && /^\d{4}-\d{2}-\d{2}$/.test(dateStr)) ? dateStr : isoFromLocalDate(day);
          const isoTomorrow = nextDayISO(isoToday);

          // Sol: posta avui i sortida dem√†
          const sunToday  = getRiseSetSameAsEfemerides(Astronomy.Body.Sun, observer, isoToday);
          const sunTom    = getRiseSetSameAsEfemerides(Astronomy.Body.Sun, observer, isoTomorrow);

          const sunset = sunToday.set;    // avui
          const sunriseNext = sunTom.rise; // dem√†

          // Lluna: posta avui i sortida dem√†
          const moonToday = getRiseSetSameAsEfemerides(Astronomy.Body.Moon, observer, isoToday);
          const moonTom   = getRiseSetSameAsEfemerides(Astronomy.Body.Moon, observer, isoTomorrow);

          const moonset = moonToday.set;       // avui
          const moonriseNext = moonTom.rise;   // dem√†

          // Inici = max(posta de sol, posta de la lluna)  (si falta una, usam l'altra)
          let start = null;
          if (sunset && moonset) start = (moonset > sunset) ? moonset : sunset;
          else start = moonset || sunset;

          // Final = min(sortida sol dem√†, sortida lluna dem√†) (si falta una, usam l'altra)
          let end = null;
          if (sunriseNext && moonriseNext) end = (moonriseNext < sunriseNext) ? moonriseNext : sunriseNext;
          else end = moonriseNext || sunriseNext;

          // Mostram nom√©s si tenim un tram coherent
          if (start && end && end > start){
            document.getElementById("astroStart").textContent = fmtTimeHM(start);
            document.getElementById("astroEnd").textContent   = fmtTimeHM(end);
            document.getElementById("astroDur").textContent   = fmtDurationHM(end.getTime() - start.getTime());
            astroCard.style.display = "block";
          }else{
            // si no podem calcular b√©, no mostram el card (per no confondre)
            astroCard.style.display = "none";
          }
        }else if (astroCard){
          astroCard.style.display = "none";
        }


        if (rise) document.getElementById("kRise").textContent = fmtTimeHM(rise);
        if (set)  document.getElementById("kSet").textContent  = fmtTimeHM(set);

        if (rise && set){
          const aboveMs = Math.max(0, set.getTime() - rise.getTime());
          document.getElementById("kAbove").textContent = fmtDurationHM(aboveMs);
        }

        let transit = null;
        let altMax = null;
        if (rise && set){
          const tr = findTransitByScan(Astronomy.Body.Moon, observer, rise, set, 5);
          if (tr){
            transit = tr.time;
            altMax = tr.altDeg;
          }
        }

        if (transit){
          const altTxt = Number.isFinite(altMax) ? Math.round(altMax) + "¬∫" : "‚Äî";
          document.getElementById("chartTitle").textContent = `${altTxt} (${fmtTimeHM(transit)})`;
        }

      }catch(e){
        console.error(e);
        const errEl = document.getElementById("err");
        errEl.style.display = "block";
        errEl.textContent = "Error: " + (e?.message || e);
      }
    })();

    // Hereta el mode nocturn de l'app (localStorage) i escolta canvis
    try{
      const apply = () => {
        const isNocturn = localStorage.getItem("nocturn") === "1";
        document.body.classList.toggle("nocturn", isNocturn);
      };
      apply();
      window.addEventListener("storage", (e) => {
        if (e.key === "nocturn") apply();
      });
    }catch(e){}
  </script>
</body>
</html>
